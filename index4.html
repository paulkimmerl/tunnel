<!DOCTYPE html><html lang="de"><head><meta charset="UTF-8"/><title>Tunnel Feedback</title><style>body{margin:0;overflow:hidden;background:#000}canvas{display:block}#ui{position:absolute;top:10px;left:10px;color:#fff;font-family:sans-serif;z-index:10}#ui label{display:block;margin-bottom:5px}</style></head><body><div id="ui"><label>Scale:<input id="scale" type="range" min="1.0" max="1.1" step="0.001" value="1.05"></label><label>Opacity:<input id="opacity" type="range" min="0" max="0.3" step="0.005" value="0.15"></label><label>Brightness:<input id="brightness" type="range" min="0.5" max="3.0" step="0.05" value="1.8"></label></div><script type="module">import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';import{ImprovedNoise}from'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/math/ImprovedNoise.js';const scene=new THREE.Scene();scene.fog=new THREE.FogExp2(0x000000,.025);const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,1e3);camera.position.set(0,0,5);camera.lookAt(0,0,0);const renderer=new THREE.WebGLRenderer({antialias:true,preserveDrawingBuffer:true});renderer.setSize(window.innerWidth,window.innerHeight);renderer.setClearColor(0x000000);document.body.appendChild(renderer.domElement);const noise=new ImprovedNoise(),radialCount=64,segmentLength=200,spacingZ=.15,radius=3,sectionsCount=3,totalInstances=radialCount*segmentLength*sectionsCount,boxGeo=new THREE.BoxGeometry(.1,.3,.05),boxMat=new THREE.MeshStandardMaterial({color:0x888888,roughness:.4,metalness:1}),mesh=new THREE.InstancedMesh(boxGeo,boxMat,totalInstances);mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);scene.add(mesh);const dummy=new THREE.Object3D;let phase=0,loopLength=segmentLength*sectionsCount,targetPhase=0;window.addEventListener('wheel',e=>{targetPhase+=e.deltaY*.3;if(targetPhase<0)targetPhase=0},{passive:true});let touchStartY=null;window.addEventListener('touchstart',e=>{if(e.touches.length===1)touchStartY=e.touches[0].clientY},{passive:true});window.addEventListener('touchmove',e=>{if(e.touches.length===1&&touchStartY!==null){let d=touchStartY-e.touches[0].clientY;targetPhase+=d*.5;if(targetPhase<0)targetPhase=0;touchStartY=e.touches[0].clientY}},{passive:true});window.addEventListener('touchend',()=>{touchStartY=null});class TunnelLight{constructor(){this.light=new THREE.PointLight(0xffffff,0,30);scene.add(this.light);this.reset(!0);this.waitTime=0}reset(init=false){this.direction=Math.random()<.5?1:-1;this.speed=(Math.random()*.2+.2)*this.direction;const maxZ=loopLength*spacingZ*3;this.posZ=(Math.random()*1.4-.2)*maxZ;this.angleOffset=Math.random()*Math.PI*2;if(!init)this.waitTime=THREE.MathUtils.randFloat(1,4);this.light.intensity=0;this.light.intensityBase=THREE.MathUtils.randFloat(.55,.95);this.light.distance=THREE.MathUtils.randFloat(20,40)}update(d){if(this.waitTime>0){this.waitTime-=d;this.light.intensity=0;return}this.posZ+=this.speed*d*60;const maxZ=loopLength*spacingZ*3;if(this.posZ>maxZ*1.2||this.posZ<-maxZ*.2){this.reset();return}let fS=-maxZ*.2,fE=maxZ*1.2,fR=.3*maxZ;if(this.posZ<fS+fR)this.light.intensity=THREE.MathUtils.clamp((this.posZ-fS)/fR,0,1)*this.light.intensityBase;else if(this.posZ>fE-fR)this.light.intensity=THREE.MathUtils.clamp((fE-this.posZ)/fR,0,1)*this.light.intensityBase;else this.light.intensity=this.light.intensityBase;const a=this.posZ*.1+this.angleOffset+performance.now()*.001,r=radius-.5;this.light.position.set(Math.cos(a)*r,Math.sin(a)*r,-this.posZ)}}const lights=[];for(let i=0;i<20;i++)lights.push(new TunnelLight);function noisePos(x,y,t){return noise.noise(x*.3+t*.1,y*.3+t*.1,t*.01)*1.3+noise.noise(x*.8-t*.05,y*.8+.07,t*.015)*.4}function noiseScale(x,y,t){return noise.noise(x*1.5+t*.25,y*1.5-t*.2,t*.2)*1.3+noise.noise(x*2-t*.1,y*2+.12,t*.18)*.4}function updateTunnel(t){let idx=0;const wA=THREE.MathUtils.mapLinear(Math.sin(t*.07),-1,1,.7,1.5);for(let s=0;s<sectionsCount;s++)for(let i=0;i<segmentLength;i++){const ti=(s*segmentLength+i+Math.floor(phase))%loopLength;for(let j=0;j<radialCount;j++){const aB=(j/radialCount)*Math.PI*2,w=noisePos(ti*.2,j*.15,t)*wA*1.5,r=radius+w,x=Math.cos(aB)*r,y=Math.sin(aB)*r,yO=noisePos(ti*.1+100,j*.1+200,t)*wA*1.3,posZ=-((s*segmentLength+i)*spacingZ*1.02);dummy.position.set(x,y+yO,posZ);dummy.rotation.z=aB+w*2.5;const sc=THREE.MathUtils.mapLinear(noiseScale(ti,j,t),-1,1,.5,1.5)*wA;dummy.scale.set(sc*.3,sc*.7,sc*.3);dummy.updateMatrix();mesh.setMatrixAt(idx++,dummy.matrix)}}mesh.instanceMatrix.needsUpdate=!0;lights.forEach(l=>l.update(.016))}const feedbackRT=new THREE.WebGLRenderTarget(window.innerWidth,window.innerHeight),feedbackScene=new THREE.Scene(),feedbackCamera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),feedbackMaterial=new THREE.ShaderMaterial({uniforms:{tOld:{value:feedbackRT.texture},tNew:{value:null},opacity:{value:0.18},scale:{value:1.05},brightness:{value:2}},vertexShader:`varying vec2 vUv; void main(){vUv=uv; gl_Position=vec4(position,1.0);}`,fragmentShader:`uniform sampler2D tOld; uniform sampler2D tNew; uniform float opacity; uniform float scale; uniform float brightness; varying vec2 vUv; void main(){vec2 uv=vUv*scale+0.5*(1.0-scale); vec4 oldColor=texture2D(tOld,uv)*opacity; vec4 newColor=texture2D(tNew,vUv); vec4 outColor=newColor+oldColor; outColor.rgb*=brightness; gl_FragColor=outColor;}`});const feedbackQuad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),feedbackMaterial);feedbackScene.add(feedbackQuad);const scaleSlider=document.getElementById("scale"),opacitySlider=document.getElementById("opacity"),brightnessSlider=document.getElementById("brightness");scaleSlider.addEventListener('input',()=>{feedbackMaterial.uniforms.scale.value=parseFloat(scaleSlider.value)});opacitySlider.addEventListener('input',()=>{feedbackMaterial.uniforms.opacity.value=parseFloat(opacitySlider.value)});brightnessSlider.addEventListener('input',()=>{feedbackMaterial.uniforms.brightness.value=parseFloat(brightnessSlider.value)});function animate(t=0){t*=.001;phase+=(targetPhase-phase)*.08;if(phase<0)phase=0;updateTunnel(t);renderer.setRenderTarget(null);renderer.render(scene,camera);feedbackMaterial.uniforms.tNew.value=renderer.domElement.texture;renderer.setRenderTarget(feedbackRT);renderer.render(feedbackScene,feedbackCamera);renderer.setRenderTarget(null);requestAnimationFrame(animate)}window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)});animate();</script></body></html>

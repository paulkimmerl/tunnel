<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Tunnel mit monochromen Graustufen & sanfteren Reflexionen</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { 
    display: block; 
    filter: grayscale(100%); /* GANZ WICHTIG: Macht alles schwarz-wei√ü */
  }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
import { ImprovedNoise } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/math/ImprovedNoise.js';

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.025);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 5);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000);
renderer.outputColorSpace = THREE.NoColorSpace; // Keine Farbkorrektur

document.body.appendChild(renderer.domElement);

const noise = new ImprovedNoise();

const radialCount = 64;
const segmentLength = 200;
const spacingZ = 0.15;
const radius = 3;
const sectionsCount = 3;
const totalInstances = radialCount * segmentLength * sectionsCount;

const boxGeo = new THREE.BoxGeometry(0.1, 0.3, 0.05);

const boxMat = new THREE.MeshStandardMaterial({
  color: 0x888888,     
  roughness: 0.4,      
  metalness: 1.0,      
  envMapIntensity: 1.0,
});
const mesh = new THREE.InstancedMesh(boxGeo, boxMat, totalInstances);
mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
scene.add(mesh);

const dummy = new THREE.Object3D();

let phase = 0;
const loopLength = segmentLength * sectionsCount;

let targetPhase = 0;
window.addEventListener('wheel', e => {
  targetPhase += e.deltaY * 0.3;
  if(targetPhase < 0) targetPhase = 0;
}, {passive:true});

let touchStartY = null;
window.addEventListener('touchstart', e => {
  if(e.touches.length === 1) touchStartY = e.touches[0].clientY;
}, {passive:true});
window.addEventListener('touchmove', e => {
  if(e.touches.length === 1 && touchStartY !== null){
    let delta = touchStartY - e.touches[0].clientY;
    targetPhase += delta * 0.5;
    if(targetPhase < 0) targetPhase = 0;
    touchStartY = e.touches[0].clientY;
  }
}, {passive:true});
window.addEventListener('touchend', () => { touchStartY = null; });

class TunnelLight {
  constructor(){
    this.light = new THREE.PointLight(0xffffff, 0, 30);
    this.light.distance = 30;
    scene.add(this.light);
    this.reset(true);
    this.waitTime = 0;
  }
  reset(init=false){
    this.direction = Math.random() < 0.5 ? 1 : -1;
    this.speed = (Math.random() * 0.5 + 0.8) * this.direction;
    const maxZ = loopLength * spacingZ * 3;
    this.posZ = (Math.random() * 1.4 - 0.2) * maxZ;
    this.angleOffset = Math.random() * Math.PI * 2;
    if(!init) this.waitTime = THREE.MathUtils.randFloat(1, 4);
    this.light.intensity = 0;
    this.light.intensityBase = THREE.MathUtils.randFloat(0.55, 0.95);
    this.light.distance = THREE.MathUtils.randFloat(20, 40);
  }
  update(delta){
    if(this.waitTime > 0){
      this.waitTime -= delta;
      this.light.intensity = 0;
      return;
    }
    this.posZ += this.speed * delta * 60;
    const maxZ = loopLength * spacingZ * 3;

    if(this.posZ > maxZ * 1.2 || this.posZ < -maxZ * 0.2) {
      this.reset();
      return;
    }

    let fadeStart = -maxZ * 0.2;
    let fadeEnd = maxZ * 1.2;
    let fadeRange = 0.3 * maxZ;

    if(this.posZ < fadeStart + fadeRange) {
      this.light.intensity = THREE.MathUtils.clamp((this.posZ - fadeStart) / fadeRange, 0, 1) * this.light.intensityBase;
    } else if(this.posZ > fadeEnd - fadeRange) {
      this.light.intensity = THREE.MathUtils.clamp((fadeEnd - this.posZ) / fadeRange, 0, 1) * this.light.intensityBase;
    } else {
      this.light.intensity = this.light.intensityBase;
    }

    const angle = this.posZ * 0.1 + this.angleOffset + performance.now() * 0.001;
    const r = radius - 0.5;
    this.light.position.set(Math.cos(angle) * r, Math.sin(angle) * r, -this.posZ);
  }
}

const lightsCount = 20;
const lights = [];
for(let i=0; i<lightsCount; i++) lights.push(new TunnelLight());

function noisePos(x, y, t){
  let base = noise.noise(x * 0.3 + t * 0.1, y * 0.3 + t * 0.1, t * 0.01);
  let mod = noise.noise(x * 0.8 - t * 0.05, y * 0.8 + t * 0.07, t * 0.015);
  return base * 1.3 + mod * 0.4;
}
function noiseScale(x, y, t){
  let base = noise.noise(x * 1.5 + t * 0.25, y * 1.5 - t * 0.2, t * 0.2);
  let mod = noise.noise(x * 2.0 - t * 0.1, y * 2.0 + t * 0.12, t * 0.18);
  return base * 1.3 + mod * 0.4;
}

function updateTunnel(time){
  let idx=0;
  const waveAmp = THREE.MathUtils.mapLinear(Math.sin(time * 0.07), -1, 1, 0.7, 1.5);

  for(let s=0; s<sectionsCount; s++){
    for(let i=0; i<segmentLength; i++){
      const tunnelIndex = (s * segmentLength + i + Math.floor(phase)) % loopLength;

      for(let j=0; j<radialCount; j++){
        const angleBase = (j / radialCount) * Math.PI * 2;

        const wpos = noisePos(tunnelIndex * 0.2, j * 0.15, time) * waveAmp * 1.5;
        let r = radius + wpos;
        let x = Math.cos(angleBase) * r;
        let y = Math.sin(angleBase) * r;

        let yOffset = noisePos(tunnelIndex * 0.1 + 100, j * 0.1 + 200, time) * waveAmp * 1.3;

        let posZ = -((s * segmentLength + i) * spacingZ * 1.02);

        dummy.position.set(x, y + yOffset, posZ);
        dummy.rotation.z = angleBase + wpos * 2.5;

        const scNoise = noiseScale(tunnelIndex, j, time);
        const sc = THREE.MathUtils.mapLinear(scNoise, -1, 1, 0.5, 1.5) * waveAmp;

        dummy.scale.set(sc * 0.3, sc * 0.7, sc * 0.3);
        dummy.updateMatrix();
        mesh.setMatrixAt(idx++, dummy.matrix);
      }
    }
  }
  mesh.instanceMatrix.needsUpdate = true;

  const delta = 0.016;
  lights.forEach(l => l.update(delta));
}

function animate(time=0){
  time *= 0.001;

  phase += (targetPhase - phase) * 0.08;
  if(phase < 0) phase = 0;

  camera.position.set(0,0,5);
  camera.lookAt(0,0,0);

  updateTunnel(time);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>
